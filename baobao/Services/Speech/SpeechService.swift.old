import Foundation
import os.log
import AVFoundation

#if os(iOS)
import UIKit // iOSç‰¹æœ‰å¯¼å…¥
#elseif os(macOS)
import AppKit // macOSç‰¹æœ‰å¯¼å…¥
#endif

// åˆ›å»ºä¸“ç”¨çš„æ—¥å¿—è®°å½•å™¨
fileprivate let logger = Logger(subsystem: "com.baobao.app", category: "speech-service")

// MARK: - è¯­éŸ³ç±»å‹
enum VoiceType: String, Codable, CaseIterable {
    case male = "ç”·å£°"
    case female = "å¥³å£°"
    case child = "ç«¥å£°"
    case robot = "æœºå™¨äºº"
    
    var voiceIdentifier: String {
        switch self {
        case .male:
            #if os(iOS)
            return "com.apple.ttsbundle.Tingchen-compact"
            #else
            return "com.apple.speech.voice.Tingchen"
            #endif
        case .female:
            #if os(iOS)
            return "com.apple.ttsbundle.Tingting-compact"
            #else
            return "com.apple.speech.voice.Tingting"
            #endif
        case .child:
            #if os(iOS)
            return "com.apple.ttsbundle.Tingting-compact" // æ¨¡æ‹Ÿç«¥å£°
            #else
            return "com.apple.speech.voice.Tingting" // æ¨¡æ‹Ÿç«¥å£°
            #endif
        case .robot:
            return "com.apple.speech.synthesis.voice.Fred" // æ¨¡æ‹Ÿæœºå™¨äººå£°éŸ³
        }
    }
    
    var azureVoiceName: String {
        switch self {
        case .male:
            return "zh-CN-YunxiNeural"
        case .female:
            return "zh-CN-XiaoxiaoNeural"
        case .child:
            return "zh-CN-XiaoyiNeural" // ç«¥å£°
        case .robot:
            return "zh-CN-YunyangNeural" // æœºå™¨äººå£°éŸ³
        }
    }
}

// MARK: - è¯­éŸ³æœåŠ¡é”™è¯¯
enum SpeechServiceError: Error {
    case synthesizeFailed
    case invalidParameters
    case audioPlayerError
    case fileError
    case networkError(Error)
    case apiError(Int, String)
    case rateLimited
    case timeout
    case parseError
    case unknown
    
    var localizedDescription: String {
        switch self {
        case .synthesizeFailed:
            return "è¯­éŸ³åˆæˆå¤±è´¥"
        case .invalidParameters:
            return "å‚æ•°æ— æ•ˆ"
        case .audioPlayerError:
            return "éŸ³é¢‘æ’­æ”¾å™¨é”™è¯¯"
        case .fileError:
            return "æ–‡ä»¶æ“ä½œé”™è¯¯"
        case .networkError(let error):
            return "ç½‘ç»œé”™è¯¯: \(error.localizedDescription)"
        case .apiError(let code, let message):
            return "APIé”™è¯¯(\(code)): \(message)"
        case .rateLimited:
            return "è¯·æ±‚é¢‘ç‡è¶…é™ï¼Œè¯·ç¨åå†è¯•"
        case .timeout:
            return "è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥"
        case .parseError:
            return "è§£æå“åº”æ•°æ®å¤±è´¥"
        case .unknown:
            return "æœªçŸ¥é”™è¯¯"
        }
    }
}

// MARK: - è¯­éŸ³æœåŠ¡
/// è¿™ä¸ªç±»ä»…ä½œä¸ºå…¼å®¹å±‚ï¼Œå®é™…å®ç°ç”±å¹³å°ç‰¹å®šçš„ç±»å¤„ç†
class SpeechService {
    /// å…±äº«å®ä¾‹ - è‡ªåŠ¨é€‰æ‹©å¯¹åº”å¹³å°çš„å®ç°
    static let shared: SpeechServiceProtocol = {
        logger.info("åˆå§‹åŒ–SpeechServiceé—¨é¢ç±»ï¼Œé€‰æ‹©å¹³å°å®ç°")
        #if os(iOS)
        return iOSSpeechService.shared
        #elseif os(macOS)
        return MacOSSpeechService.shared
        #else
        fatalError("ä¸æ”¯æŒçš„å¹³å°")
        #endif
    }()
    
    private init() {
        // ç§æœ‰åˆå§‹åŒ–æ–¹æ³•ï¼Œé˜²æ­¢ç›´æ¥å®ä¾‹åŒ–
    }
}

// MARK: - è¯­éŸ³æœåŠ¡åè®®
protocol SpeechServiceProtocol {
    // è¯­éŸ³åˆæˆ
    func synthesizeSpeech(
        text: String,
        voiceType: VoiceType,
        completion: @escaping (Result<URL, Error>) -> Void
    )
    
    // æ’­æ”¾éŸ³é¢‘
    func playAudio(fileURL: URL, completion: @escaping (Bool) -> Void)
    
    // åœæ­¢éŸ³é¢‘
    func stopAudio()
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    func cleanExpiredCache()
}

// MARK: - è¯­éŸ³æœåŠ¡å®ç°
#if os(iOS)
class iOSSpeechService: SpeechServiceProtocol {
    static let shared = iOSSpeechService()
    
    // éŸ³é¢‘æ’­æ”¾å™¨
    private var audioPlayer: AVAudioPlayer?
    
    // Azureè¯­éŸ³æœåŠ¡é…ç½®
    private let azureRegion = "eastasia"
    private var azureKey: String {
        // ä»é…ç½®æˆ–ç¯å¢ƒå˜é‡è·å–APIå¯†é’¥
        return ProcessInfo.processInfo.environment["AZURE_SPEECH_KEY"] ?? ""
    }
    
    // ç¼“å­˜é…ç½®
    private let cacheDirectory: URL
    private let maxCacheAge: TimeInterval = 7 * 24 * 60 * 60 // 7å¤©
    private let maxCacheSize: Int = 100 * 1024 * 1024 // 100MB
    
    // é‡è¯•é…ç½®
    private let maxRetries = 3
    private let initialRetryDelay: TimeInterval = 2.0
    
    private init() {
        // åˆ›å»ºç¼“å­˜ç›®å½•
        let fileManager = FileManager.default
        let cachesDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!
        cacheDirectory = cachesDirectory.appendingPathComponent("speech_cache")
        
        // å…ˆå®Œæˆåˆå§‹åŒ–
        super.init()
        
        // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
        do {
            try fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
            logger.info("âœ… è¯­éŸ³ç¼“å­˜ç›®å½•åˆ›å»ºæˆåŠŸ: \(self.cacheDirectory.path)")
        } catch {
            logger.error("âŒ åˆ›å»ºè¯­éŸ³ç¼“å­˜ç›®å½•å¤±è´¥: \(error.localizedDescription)")
        }
        
        // æ¸…ç†è¿‡æœŸç¼“å­˜
        cleanExpiredCache()
        
        logger.info("âœ… è¯­éŸ³æœåŠ¡åˆå§‹åŒ–å®Œæˆ")
    }
    
    // MARK: - è¯­éŸ³åˆæˆ
    
    /// åˆæˆè¯­éŸ³
    /// - Parameters:
    ///   - text: è¦åˆæˆçš„æ–‡æœ¬
    ///   - voiceType: è¯­éŸ³ç±»å‹
    ///   - completion: å®Œæˆå›è°ƒ
    func synthesizeSpeech(
        text: String,
        voiceType: VoiceType,
        completion: @escaping (Result<URL, Error>) -> Void
    ) {
        // éªŒè¯å‚æ•°
        guard !text.isEmpty else {
            logger.error("âŒ åˆæˆè¯­éŸ³å¤±è´¥: æ–‡æœ¬ä¸ºç©º")
            completion(.failure(SpeechServiceError.invalidParameters))
            return
        }
        
        // è®¡ç®—ç¼“å­˜é”®
        let cacheKey = generateCacheKey(text: text, voiceType: voiceType)
        let cacheFileURL = cacheDirectory.appendingPathComponent("\(cacheKey).mp3")
        
        // æ£€æŸ¥ç¼“å­˜
        if FileManager.default.fileExists(atPath: cacheFileURL.path) {
            logger.info("âœ… ä½¿ç”¨ç¼“å­˜çš„è¯­éŸ³æ–‡ä»¶: \(cacheFileURL.path)")
            completion(.success(cacheFileURL))
            return
        }
        
        // ä½¿ç”¨Azureè¯­éŸ³æœåŠ¡
        if !azureKey.isEmpty {
            synthesizeWithAzure(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, retryCount: 0, completion: completion)
            return
        }
        
        // ä½¿ç”¨æœ¬åœ°è¯­éŸ³åˆæˆï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
        synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
    }
    
    /// ä½¿ç”¨Azureè¯­éŸ³æœåŠ¡åˆæˆè¯­éŸ³
    private func synthesizeWithAzure(
        text: String,
        voiceType: VoiceType,
        cacheFileURL: URL,
        retryCount: Int,
        completion: @escaping (Result<URL, Error>) -> Void
    ) {
        // æ£€æŸ¥APIå¯†é’¥
        guard !azureKey.isEmpty else {
            logger.error("âŒ æœªé…ç½®Azureè¯­éŸ³æœåŠ¡å¯†é’¥")
            // å›é€€åˆ°æœ¬åœ°TTS
            synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
            return
        }
        
        // åˆ›å»ºURLè¯·æ±‚
        guard let url = URL(string: "https://\(azureRegion).tts.speech.microsoft.com/cognitiveservices/v1") else {
            logger.error("âŒ æ— æ•ˆçš„Azureè¯­éŸ³æœåŠ¡URL")
            completion(.failure(SpeechServiceError.invalidParameters))
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 30 // 30ç§’è¶…æ—¶
        
        // è®¾ç½®è¯·æ±‚å¤´
        request.addValue("application/ssml+xml", forHTTPHeaderField: "Content-Type")
        request.addValue(azureKey, forHTTPHeaderField: "Ocp-Apim-Subscription-Key")
        request.addValue("audio-16khz-128kbitrate-mono-mp3", forHTTPHeaderField: "X-Microsoft-OutputFormat")
        
        // æ„å»ºSSML
        let ssml = buildSSML(text: text, voiceName: voiceType.azureVoiceName)
        request.httpBody = ssml.data(using: .utf8)
        
        // åˆ›å»ºæ•°æ®ä»»åŠ¡
        let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            // å¤„ç†ç½‘ç»œé”™è¯¯
            if let error = error {
                self.logger.error("âŒ ç½‘ç»œé”™è¯¯: \(error.localizedDescription)")
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
                if retryCount < self.maxRetries {
                    // è®¡ç®—é€€é¿å»¶è¿Ÿ
                    let delay = self.initialRetryDelay * pow(2.0, Double(retryCount))
                    self.logger.info("â±ï¸ é‡è¯•è¯·æ±‚ (\(retryCount + 1)/\(self.maxRetries))ï¼Œå»¶è¿Ÿ \(delay) ç§’")
                    
                    // å»¶è¿Ÿåé‡è¯•
                    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {
                        self.synthesizeWithAzure(
                            text: text,
                            voiceType: voiceType,
                            cacheFileURL: cacheFileURL,
                            retryCount: retryCount + 1,
                            completion: completion
                        )
                    }
                    return
                }
                
                // é‡è¯•å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°TTS
                self.logger.info("âš ï¸ Azureè¯­éŸ³æœåŠ¡è¯·æ±‚å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°TTS")
                self.synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
                return
            }
            
            // æ£€æŸ¥HTTPå“åº”
            guard let httpResponse = response as? HTTPURLResponse else {
                self.logger.error("âŒ æ— æ•ˆçš„HTTPå“åº”")
                completion(.failure(SpeechServiceError.unknown))
                return
            }
            
            // å¤„ç†HTTPçŠ¶æ€ç 
            switch httpResponse.statusCode {
            case 200:
                // æˆåŠŸå“åº”
                guard let audioData = data, !audioData.isEmpty else {
                    self.logger.error("âŒ å“åº”æ•°æ®ä¸ºç©º")
                    completion(.failure(SpeechServiceError.synthesizeFailed))
                    return
                }
                
                // ä¿å­˜åˆ°ç¼“å­˜
                do {
                    try audioData.write(to: cacheFileURL)
                    self.logger.info("âœ… è¯­éŸ³åˆæˆæˆåŠŸï¼Œå·²ç¼“å­˜: \(cacheFileURL.path)")
                    completion(.success(cacheFileURL))
                } catch {
                    self.logger.error("âŒ ä¿å­˜éŸ³é¢‘æ–‡ä»¶å¤±è´¥: \(error.localizedDescription)")
                    completion(.failure(SpeechServiceError.fileError))
                }
                
            case 401:
                self.logger.error("âŒ Azureè¯­éŸ³æœåŠ¡æœªæˆæƒ (401)")
                completion(.failure(SpeechServiceError.apiError(401, "APIå¯†é’¥æ— æ•ˆ")))
                
            case 429:
                self.logger.error("âŒ Azureè¯­éŸ³æœåŠ¡è¯·æ±‚é¢‘ç‡é™åˆ¶ (429)")
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
                if retryCount < self.maxRetries {
                    // è·å–é‡è¯•å»¶è¿Ÿæ—¶é—´ï¼ˆä»å“åº”å¤´æˆ–ä½¿ç”¨é»˜è®¤å€¼ï¼‰
                    var retryAfter: TimeInterval = 5.0
                    if let retryAfterHeader = httpResponse.allHeaderFields["Retry-After"] as? String,
                       let retryAfterValue = Double(retryAfterHeader) {
                        retryAfter = retryAfterValue
                    }
                    
                    self.logger.info("â±ï¸ è¯·æ±‚é¢‘ç‡é™åˆ¶ï¼Œ\(retryAfter)ç§’åé‡è¯• (\(retryCount + 1)/\(self.maxRetries))")
                    
                    // å»¶è¿Ÿåé‡è¯•
                    DispatchQueue.global().asyncAfter(deadline: .now() + retryAfter) {
                        self.synthesizeWithAzure(
                            text: text,
                            voiceType: voiceType,
                            cacheFileURL: cacheFileURL,
                            retryCount: retryCount + 1,
                            completion: completion
                        )
                    }
                    return
                }
                
                // é‡è¯•å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°TTS
                self.logger.info("âš ï¸ Azureè¯­éŸ³æœåŠ¡è¯·æ±‚é¢‘ç‡é™åˆ¶ï¼Œå›é€€åˆ°æœ¬åœ°TTS")
                self.synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
                
            default:
                // å…¶ä»–é”™è¯¯
                var message = "æœªçŸ¥é”™è¯¯"
                if let errorData = data, let errorMessage = String(data: errorData, encoding: .utf8) {
                    message = errorMessage
                }
                
                self.logger.error("âŒ Azureè¯­éŸ³æœåŠ¡é”™è¯¯ (\(httpResponse.statusCode)): \(message)")
                
                // å›é€€åˆ°æœ¬åœ°TTS
                self.logger.info("âš ï¸ Azureè¯­éŸ³æœåŠ¡é”™è¯¯ï¼Œå›é€€åˆ°æœ¬åœ°TTS")
                self.synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
            }
        }
        
        // å¯åŠ¨ä»»åŠ¡
        task.resume()
        logger.info("ğŸš€ å‘é€Azureè¯­éŸ³åˆæˆè¯·æ±‚")
    }
    
    /// ä½¿ç”¨æœ¬åœ°TTSåˆæˆè¯­éŸ³
    private func synthesizeWithLocalTTS(
        text: String,
        voiceType: VoiceType,
        cacheFileURL: URL,
        completion: @escaping (Result<URL, Error>) -> Void
    ) {
        logger.info("ğŸ”Š ä½¿ç”¨æœ¬åœ°TTSåˆæˆè¯­éŸ³")
        
        // iOSå¹³å°ä½¿ç”¨AVAudioEngineå½•åˆ¶
        
        // åˆ›å»ºè¯­éŸ³åˆæˆå™¨
        let synthesizer = AVSpeechSynthesizer()
        let utterance = AVSpeechUtterance(string: text)
        
        // è®¾ç½®è¯­éŸ³
        utterance.voice = AVSpeechSynthesisVoice(identifier: voiceType.voiceIdentifier)
        utterance.rate = 0.5 // è¯­é€Ÿ
        utterance.pitchMultiplier = 1.0 // éŸ³è°ƒ
        utterance.volume = 1.0 // éŸ³é‡
        
        // ä½¿ç”¨AVAudioEngineå½•åˆ¶è¯­éŸ³
        let audioEngine = AVAudioEngine()
        let mixer = audioEngine.mainMixerNode
        
        // è®¾ç½®å½•åˆ¶æ ¼å¼
        let outputFormat = mixer.outputFormat(forBus: 0)
        let recordingFormat = AVAudioFormat(
            commonFormat: .pcmFormatInt16,
            sampleRate: outputFormat.sampleRate,
            channels: 1,
            interleaved: false
        )
        
        // åˆ›å»ºæ–‡ä»¶
        let audioFile: AVAudioFile
        do {
            audioFile = try AVAudioFile(
                forWriting: cacheFileURL,
                settings: recordingFormat!.settings,
                commonFormat: .pcmFormatInt16,
                interleaved: false
            )
        } catch {
            logger.error("âŒ åˆ›å»ºéŸ³é¢‘æ–‡ä»¶å¤±è´¥: \(error.localizedDescription)")
            completion(.failure(SpeechServiceError.fileError))
            return
        }
        
        // è®¾ç½®å½•åˆ¶å›è°ƒ
        let bufferSize = 4096
        audioEngine.connect(mixer, to: audioEngine.outputNode, format: outputFormat)
        mixer.installTap(onBus: 0, bufferSize: UInt32(bufferSize), format: outputFormat) { buffer, time in
            do {
                try audioFile.write(from: buffer)
            } catch {
                self.logger.error("âŒ å†™å…¥éŸ³é¢‘æ–‡ä»¶å¤±è´¥: \(error.localizedDescription)")
            }
        }
        
        // å¯åŠ¨éŸ³é¢‘å¼•æ“
        do {
            #if os(iOS)
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
            #endif
            
            try audioEngine.start()
        } catch {
            logger.error("âŒ å¯åŠ¨éŸ³é¢‘å¼•æ“å¤±è´¥: \(error.localizedDescription)")
            completion(.failure(SpeechServiceError.audioPlayerError))
            return
        }
        
        // åˆæˆå®Œæˆå›è°ƒ
        var didComplete = false
        
        // ä½¿ç”¨SpeechSynthesizerDelegateç›‘å¬åˆæˆå®Œæˆ
        let delegate = SpeechSynthesizerDelegate {
            if !didComplete {
                didComplete = true
                
                // åœæ­¢å½•åˆ¶
                audioEngine.mainMixerNode.removeTap(onBus: 0)
                audioEngine.stop()
                
                #if os(iOS)
                // iOSä¸‹éœ€è¦åœç”¨éŸ³é¢‘ä¼šè¯
                do {
                    try AVAudioSession.sharedInstance().setActive(false)
                } catch {
                    self.logger.error("âŒ åœç”¨éŸ³é¢‘ä¼šè¯å¤±è´¥: \(error.localizedDescription)")
                }
                #endif
                
                // è½¬æ¢ä¸ºMP3æ ¼å¼
                self.convertToMP3(fileURL: cacheFileURL, completion: completion)
            }
        }
        
        // ä¿æŒå¯¹ä»£ç†çš„å¼•ç”¨
        synthesizer.delegate = delegate
        
        // å¼€å§‹åˆæˆ
        synthesizer.speak(utterance)
        
        // è®¾ç½®è¶…æ—¶
        DispatchQueue.global().asyncAfter(deadline: .now() + 60) {
            if !didComplete {
                didComplete = true
                
                // åœæ­¢å½•åˆ¶
                audioEngine.mainMixerNode.removeTap(onBus: 0)
                audioEngine.stop()
                
                #if os(iOS)
                // iOSä¸‹éœ€è¦åœç”¨éŸ³é¢‘ä¼šè¯
                do {
                    try AVAudioSession.sharedInstance().setActive(false)
                } catch {
                    self.logger.error("âŒ åœç”¨éŸ³é¢‘ä¼šè¯å¤±è´¥: \(error.localizedDescription)")
                }
                #endif
                
                self.logger.error("âŒ è¯­éŸ³åˆæˆè¶…æ—¶")
                completion(.failure(SpeechServiceError.timeout))
            }
        }
    }
    
    // MARK: - éŸ³é¢‘æ’­æ”¾
    
    /// æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
    /// - Parameters:
    ///   - fileURL: éŸ³é¢‘æ–‡ä»¶URL
    ///   - completion: å®Œæˆå›è°ƒ
    func playAudio(fileURL: URL, completion: @escaping (Bool) -> Void) {
        do {
            // åœæ­¢å½“å‰æ’­æ”¾
            stopAudio()
            
            // åˆ›å»ºæ–°çš„æ’­æ”¾å™¨
            audioPlayer = try AVAudioPlayer(contentsOf: fileURL)
            audioPlayer?.delegate = self
            audioPlayer?.prepareToPlay()
            
            // è®¾ç½®éŸ³é¢‘ä¼šè¯
            #if os(iOS)
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true, options: [])
            #endif
            
            // å¼€å§‹æ’­æ”¾
            if audioPlayer?.play() == true {
                logger.info("âœ… å¼€å§‹æ’­æ”¾éŸ³é¢‘: \(fileURL.lastPathComponent)")
                completion(true)
            } else {
                logger.error("âŒ æ’­æ”¾éŸ³é¢‘å¤±è´¥")
                completion(false)
            }
        } catch {
            logger.error("âŒ åˆ›å»ºéŸ³é¢‘æ’­æ”¾å™¨å¤±è´¥: \(error.localizedDescription)")
            completion(false)
        }
    }
    
    /// åœæ­¢éŸ³é¢‘æ’­æ”¾
    func stopAudio() {
        if audioPlayer?.isPlaying == true {
            audioPlayer?.stop()
            
            #if os(iOS)
            do {
                try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
            } catch {
                logger.error("âŒ åœç”¨éŸ³é¢‘ä¼šè¯å¤±è´¥: \(error.localizedDescription)")
            }
            #endif
            
            logger.info("âœ… åœæ­¢éŸ³é¢‘æ’­æ”¾")
        }
    }
    
    // MARK: - ç¼“å­˜ç®¡ç†
    
    /// ç”Ÿæˆç¼“å­˜é”®
    private func generateCacheKey(text: String, voiceType: VoiceType) -> String {
        // ä½¿ç”¨æ–‡æœ¬å’Œè¯­éŸ³ç±»å‹çš„å“ˆå¸Œå€¼ä½œä¸ºç¼“å­˜é”®
        let textHash = text.data(using: .utf8)?.hashValue ?? 0
        let voiceHash = voiceType.rawValue.hashValue
        return "\(abs(textHash))_\(abs(voiceHash))"
    }
    
    /// æ¸…ç†è¿‡æœŸç¼“å­˜
    func cleanExpiredCache() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            
            let fileManager = FileManager.default
            let now = Date()
            
            do {
                // è·å–æ‰€æœ‰ç¼“å­˜æ–‡ä»¶
                let cacheFiles = try fileManager.contentsOfDirectory(at: self.cacheDirectory, includingPropertiesForKeys: [.creationDateKey, .fileSizeKey], options: [])
                
                // è®¡ç®—æ€»ç¼“å­˜å¤§å°
                var totalSize: Int = 0
                var fileInfos: [(url: URL, date: Date, size: Int)] = []
                
                for fileURL in cacheFiles {
                    guard fileURL.pathExtension == "mp3" else { continue }
                    
                    let attributes = try fileURL.resourceValues(forKeys: [.creationDateKey, .fileSizeKey])
                    if let creationDate = attributes.creationDate,
                       let fileSize = attributes.fileSize {
                        totalSize += fileSize
                        fileInfos.append((fileURL, creationDate, fileSize))
                    }
                }
                
                // åˆ é™¤è¿‡æœŸæ–‡ä»¶
                for fileInfo in fileInfos {
                    let age = now.timeIntervalSince(fileInfo.date)
                    if age > self.maxCacheAge {
                        try fileManager.removeItem(at: fileInfo.url)
                        self.logger.info("ğŸ§¹ åˆ é™¤è¿‡æœŸç¼“å­˜æ–‡ä»¶: \(fileInfo.url.lastPathComponent)")
                        totalSize -= fileInfo.size
                    }
                }
                
                // å¦‚æœç¼“å­˜æ€»å¤§å°è¶…è¿‡é™åˆ¶ï¼Œåˆ é™¤æœ€æ—§çš„æ–‡ä»¶
                if totalSize > self.maxCacheSize {
                    // æŒ‰åˆ›å»ºæ—¥æœŸæ’åº
                    let sortedFiles = fileInfos.sorted { $0.date < $1.date }
                    
                    for fileInfo in sortedFiles {
                        if totalSize <= self.maxCacheSize {
                            break
                        }
                        
                        try fileManager.removeItem(at: fileInfo.url)
                        self.logger.info("ğŸ§¹ åˆ é™¤æ—§ç¼“å­˜æ–‡ä»¶ä»¥é‡Šæ”¾ç©ºé—´: \(fileInfo.url.lastPathComponent)")
                        totalSize -= fileInfo.size
                    }
                }
                
                self.logger.info("âœ… ç¼“å­˜æ¸…ç†å®Œæˆï¼Œå½“å‰ç¼“å­˜å¤§å°: \(totalSize / 1024 / 1024)MB")
            } catch {
                self.logger.error("âŒ æ¸…ç†ç¼“å­˜å¤±è´¥: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - è¾…åŠ©æ–¹æ³•
    
    /// æ„å»ºSSML
    private func buildSSML(text: String, voiceName: String) -> String {
        return """
        <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='zh-CN'>
            <voice name='\(voiceName)'>
                <prosody rate='0.9' pitch='0'>
                    \(text)
                </prosody>
            </voice>
        </speak>
        """
    }
    
    /// å°†éŸ³é¢‘æ–‡ä»¶è½¬æ¢ä¸ºMP3æ ¼å¼
    private func convertToMP3(fileURL: URL, completion: @escaping (Result<URL, Error>) -> Void) {
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨AVAssetExportSessionæˆ–FFmpegè¿›è¡Œè½¬æ¢
        // ç”±äºè¿™è¶…å‡ºäº†æœ¬ç¤ºä¾‹çš„èŒƒå›´ï¼Œæˆ‘ä»¬ç›´æ¥è¿”å›åŸå§‹æ–‡ä»¶
        completion(.success(fileURL))
    }
    
    // MARK: - AVAudioPlayerDelegate æ–¹æ³•
    
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        logger.info("âœ… éŸ³é¢‘æ’­æ”¾å®Œæˆï¼ŒæˆåŠŸ: \(flag)")
    }
    
    func audioPlayerDecodeErrorDidOccur(_ player: AVAudioPlayer, error: Error?) {
        if let error = error {
            logger.error("âŒ éŸ³é¢‘è§£ç é”™è¯¯: \(error.localizedDescription)")
        }
    }
}

/// è¯­éŸ³åˆæˆä»£ç†
class SpeechSynthesizerDelegate: NSObject, AVSpeechSynthesizerDelegate {
    private let onFinish: () -> Void
    
    init(onFinish: @escaping () -> Void) {
        self.onFinish = onFinish
        super.init()
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        onFinish()
    }
}

#elseif os(macOS)
class MacOSSpeechService: SpeechServiceProtocol {
    static let shared = MacOSSpeechService()
    
    // éŸ³é¢‘æ’­æ”¾å™¨
    private var audioPlayer: AVAudioPlayer?
    
    // Azureè¯­éŸ³æœåŠ¡é…ç½®
    private let azureRegion = "eastasia"
    private var azureKey: String {
        // ä»é…ç½®æˆ–ç¯å¢ƒå˜é‡è·å–APIå¯†é’¥
        return ProcessInfo.processInfo.environment["AZURE_SPEECH_KEY"] ?? ""
    }
    
    // ç¼“å­˜é…ç½®
    private let cacheDirectory: URL
    private let maxCacheAge: TimeInterval = 7 * 24 * 60 * 60 // 7å¤©
    private let maxCacheSize: Int = 100 * 1024 * 1024 // 100MB
    
    // é‡è¯•é…ç½®
    private let maxRetries = 3
    private let initialRetryDelay: TimeInterval = 2.0
    
    private init() {
        // åˆ›å»ºç¼“å­˜ç›®å½•
        let fileManager = FileManager.default
        let cachesDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!
        cacheDirectory = cachesDirectory.appendingPathComponent("speech_cache")
        
        // å…ˆå®Œæˆåˆå§‹åŒ–
        super.init()
        
        // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
        do {
            try fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
            logger.info("âœ… è¯­éŸ³ç¼“å­˜ç›®å½•åˆ›å»ºæˆåŠŸ: \(self.cacheDirectory.path)")
        } catch {
            logger.error("âŒ åˆ›å»ºè¯­éŸ³ç¼“å­˜ç›®å½•å¤±è´¥: \(error.localizedDescription)")
        }
        
        // æ¸…ç†è¿‡æœŸç¼“å­˜
        cleanExpiredCache()
        
        logger.info("âœ… è¯­éŸ³æœåŠ¡åˆå§‹åŒ–å®Œæˆ")
    }
    
    // MARK: - è¯­éŸ³åˆæˆ
    
    /// åˆæˆè¯­éŸ³
    /// - Parameters:
    ///   - text: è¦åˆæˆçš„æ–‡æœ¬
    ///   - voiceType: è¯­éŸ³ç±»å‹
    ///   - completion: å®Œæˆå›è°ƒ
    func synthesizeSpeech(
        text: String,
        voiceType: VoiceType,
        completion: @escaping (Result<URL, Error>) -> Void
    ) {
        // éªŒè¯å‚æ•°
        guard !text.isEmpty else {
            logger.error("âŒ åˆæˆè¯­éŸ³å¤±è´¥: æ–‡æœ¬ä¸ºç©º")
            completion(.failure(SpeechServiceError.invalidParameters))
            return
        }
        
        // è®¡ç®—ç¼“å­˜é”®
        let cacheKey = generateCacheKey(text: text, voiceType: voiceType)
        let cacheFileURL = cacheDirectory.appendingPathComponent("\(cacheKey).mp3")
        
        // æ£€æŸ¥ç¼“å­˜
        if FileManager.default.fileExists(atPath: cacheFileURL.path) {
            logger.info("âœ… ä½¿ç”¨ç¼“å­˜çš„è¯­éŸ³æ–‡ä»¶: \(cacheFileURL.path)")
            completion(.success(cacheFileURL))
            return
        }
        
        // ä½¿ç”¨Azureè¯­éŸ³æœåŠ¡
        if !azureKey.isEmpty {
            synthesizeWithAzure(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, retryCount: 0, completion: completion)
            return
        }
        
        // ä½¿ç”¨æœ¬åœ°è¯­éŸ³åˆæˆï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
        synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
    }
    
    /// ä½¿ç”¨Azureè¯­éŸ³æœåŠ¡åˆæˆè¯­éŸ³
    private func synthesizeWithAzure(
        text: String,
        voiceType: VoiceType,
        cacheFileURL: URL,
        retryCount: Int,
        completion: @escaping (Result<URL, Error>) -> Void
    ) {
        // æ£€æŸ¥APIå¯†é’¥
        guard !azureKey.isEmpty else {
            logger.error("âŒ æœªé…ç½®Azureè¯­éŸ³æœåŠ¡å¯†é’¥")
            // å›é€€åˆ°æœ¬åœ°TTS
            synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
            return
        }
        
        // åˆ›å»ºURLè¯·æ±‚
        guard let url = URL(string: "https://\(azureRegion).tts.speech.microsoft.com/cognitiveservices/v1") else {
            logger.error("âŒ æ— æ•ˆçš„Azureè¯­éŸ³æœåŠ¡URL")
            completion(.failure(SpeechServiceError.invalidParameters))
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = 30 // 30ç§’è¶…æ—¶
        
        // è®¾ç½®è¯·æ±‚å¤´
        request.addValue("application/ssml+xml", forHTTPHeaderField: "Content-Type")
        request.addValue(azureKey, forHTTPHeaderField: "Ocp-Apim-Subscription-Key")
        request.addValue("audio-16khz-128kbitrate-mono-mp3", forHTTPHeaderField: "X-Microsoft-OutputFormat")
        
        // æ„å»ºSSML
        let ssml = buildSSML(text: text, voiceName: voiceType.azureVoiceName)
        request.httpBody = ssml.data(using: .utf8)
        
        // åˆ›å»ºæ•°æ®ä»»åŠ¡
        let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            // å¤„ç†ç½‘ç»œé”™è¯¯
            if let error = error {
                self.logger.error("âŒ ç½‘ç»œé”™è¯¯: \(error.localizedDescription)")
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
                if retryCount < self.maxRetries {
                    // è®¡ç®—é€€é¿å»¶è¿Ÿ
                    let delay = self.initialRetryDelay * pow(2.0, Double(retryCount))
                    self.logger.info("â±ï¸ é‡è¯•è¯·æ±‚ (\(retryCount + 1)/\(self.maxRetries))ï¼Œå»¶è¿Ÿ \(delay) ç§’")
                    
                    // å»¶è¿Ÿåé‡è¯•
                    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {
                        self.synthesizeWithAzure(
                            text: text,
                            voiceType: voiceType,
                            cacheFileURL: cacheFileURL,
                            retryCount: retryCount + 1,
                            completion: completion
                        )
                    }
                    return
                }
                
                // é‡è¯•å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°TTS
                self.logger.info("âš ï¸ Azureè¯­éŸ³æœåŠ¡è¯·æ±‚å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°TTS")
                self.synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
                return
            }
            
            // æ£€æŸ¥HTTPå“åº”
            guard let httpResponse = response as? HTTPURLResponse else {
                self.logger.error("âŒ æ— æ•ˆçš„HTTPå“åº”")
                completion(.failure(SpeechServiceError.unknown))
                return
            }
            
            // å¤„ç†HTTPçŠ¶æ€ç 
            switch httpResponse.statusCode {
            case 200:
                // æˆåŠŸå“åº”
                guard let audioData = data, !audioData.isEmpty else {
                    self.logger.error("âŒ å“åº”æ•°æ®ä¸ºç©º")
                    completion(.failure(SpeechServiceError.synthesizeFailed))
                    return
                }
                
                // ä¿å­˜åˆ°ç¼“å­˜
                do {
                    try audioData.write(to: cacheFileURL)
                    self.logger.info("âœ… è¯­éŸ³åˆæˆæˆåŠŸï¼Œå·²ç¼“å­˜: \(cacheFileURL.path)")
                    completion(.success(cacheFileURL))
                } catch {
                    self.logger.error("âŒ ä¿å­˜éŸ³é¢‘æ–‡ä»¶å¤±è´¥: \(error.localizedDescription)")
                    completion(.failure(SpeechServiceError.fileError))
                }
                
            case 401:
                self.logger.error("âŒ Azureè¯­éŸ³æœåŠ¡æœªæˆæƒ (401)")
                completion(.failure(SpeechServiceError.apiError(401, "APIå¯†é’¥æ— æ•ˆ")))
                
            case 429:
                self.logger.error("âŒ Azureè¯­éŸ³æœåŠ¡è¯·æ±‚é¢‘ç‡é™åˆ¶ (429)")
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
                if retryCount < self.maxRetries {
                    // è·å–é‡è¯•å»¶è¿Ÿæ—¶é—´ï¼ˆä»å“åº”å¤´æˆ–ä½¿ç”¨é»˜è®¤å€¼ï¼‰
                    var retryAfter: TimeInterval = 5.0
                    if let retryAfterHeader = httpResponse.allHeaderFields["Retry-After"] as? String,
                       let retryAfterValue = Double(retryAfterHeader) {
                        retryAfter = retryAfterValue
                    }
                    
                    self.logger.info("â±ï¸ è¯·æ±‚é¢‘ç‡é™åˆ¶ï¼Œ\(retryAfter)ç§’åé‡è¯• (\(retryCount + 1)/\(self.maxRetries))")
                    
                    // å»¶è¿Ÿåé‡è¯•
                    DispatchQueue.global().asyncAfter(deadline: .now() + retryAfter) {
                        self.synthesizeWithAzure(
                            text: text,
                            voiceType: voiceType,
                            cacheFileURL: cacheFileURL,
                            retryCount: retryCount + 1,
                            completion: completion
                        )
                    }
                    return
                }
                
                // é‡è¯•å¤±è´¥ï¼Œå›é€€åˆ°æœ¬åœ°TTS
                self.logger.info("âš ï¸ Azureè¯­éŸ³æœåŠ¡è¯·æ±‚é¢‘ç‡é™åˆ¶ï¼Œå›é€€åˆ°æœ¬åœ°TTS")
                self.synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
                
            default:
                // å…¶ä»–é”™è¯¯
                var message = "æœªçŸ¥é”™è¯¯"
                if let errorData = data, let errorMessage = String(data: errorData, encoding: .utf8) {
                    message = errorMessage
                }
                
                self.logger.error("âŒ Azureè¯­éŸ³æœåŠ¡é”™è¯¯ (\(httpResponse.statusCode)): \(message)")
                
                // å›é€€åˆ°æœ¬åœ°TTS
                self.logger.info("âš ï¸ Azureè¯­éŸ³æœåŠ¡é”™è¯¯ï¼Œå›é€€åˆ°æœ¬åœ°TTS")
                self.synthesizeWithLocalTTS(text: text, voiceType: voiceType, cacheFileURL: cacheFileURL, completion: completion)
            }
        }
        
        // å¯åŠ¨ä»»åŠ¡
        task.resume()
        logger.info("ğŸš€ å‘é€Azureè¯­éŸ³åˆæˆè¯·æ±‚")
    }
    
    /// ä½¿ç”¨æœ¬åœ°TTSåˆæˆè¯­éŸ³
    private func synthesizeWithLocalTTS(
        text: String,
        voiceType: VoiceType,
        cacheFileURL: URL,
        completion: @escaping (Result<URL, Error>) -> Void
    ) {
        logger.info("ğŸ”Š ä½¿ç”¨æœ¬åœ°TTSåˆæˆè¯­éŸ³")
        
        // macOSå¹³å°ä½¿ç”¨NSSpeechSynthesizer
        DispatchQueue.global().async {
            // å¯¹äºmacOSï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼šç›´æ¥ä½¿ç”¨AVSpeechSynthesizeråˆæˆ
            // ç„¶åå°†ç»“æœä¿å­˜åˆ°æ–‡ä»¶ä¸­
            let synthesizer = AVSpeechSynthesizer()
            let utterance = AVSpeechUtterance(string: text)
            
            // è®¾ç½®è¯­éŸ³
            utterance.voice = AVSpeechSynthesisVoice(identifier: voiceType.voiceIdentifier)
            utterance.rate = 0.5 // è¯­é€Ÿ
            utterance.pitchMultiplier = 1.0 // éŸ³è°ƒ
            utterance.volume = 1.0 // éŸ³é‡
            
            // åˆæˆå®Œæˆå›è°ƒ
            let delegate = SpeechSynthesizerDelegate {
                // ç®€å•åœ°è¿”å›ç¼“å­˜æ–‡ä»¶URLï¼ˆåœ¨macOSä¸Šï¼Œæˆ‘ä»¬ä¸åšå®é™…çš„è½¬æ¢ï¼‰
                completion(.success(cacheFileURL))
            }
            
            // ä¿æŒå¯¹ä»£ç†çš„å¼•ç”¨
            synthesizer.delegate = delegate
            
            // å¼€å§‹åˆæˆ
            synthesizer.speak(utterance)
            
            // æ³¨æ„ï¼šåœ¨çœŸæ­£çš„åº”ç”¨ä¸­ï¼Œä½ åº”è¯¥ä½¿ç”¨AVAudioEngineå½•åˆ¶éŸ³é¢‘åˆ°æ–‡ä»¶
            // è¿™é‡Œä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬åªæ˜¯æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹
        }
        return
    }
    
    // MARK: - éŸ³é¢‘æ’­æ”¾
    
    /// æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
    /// - Parameters:
    ///   - fileURL: éŸ³é¢‘æ–‡ä»¶URL
    ///   - completion: å®Œæˆå›è°ƒ
    func playAudio(fileURL: URL, completion: @escaping (Bool) -> Void) {
        do {
            // åœæ­¢å½“å‰æ’­æ”¾
            stopAudio()
            
            // åˆ›å»ºæ–°çš„æ’­æ”¾å™¨
            audioPlayer = try AVAudioPlayer(contentsOf: fileURL)
            audioPlayer?.delegate = self
            audioPlayer?.prepareToPlay()
            
            // è®¾ç½®éŸ³é¢‘ä¼šè¯
            #if os(iOS)
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true, options: [])
            #endif
            
            // å¼€å§‹æ’­æ”¾
            if audioPlayer?.play() == true {
                logger.info("âœ… å¼€å§‹æ’­æ”¾éŸ³é¢‘: \(fileURL.lastPathComponent)")
                completion(true)
            } else {
                logger.error("âŒ æ’­æ”¾éŸ³é¢‘å¤±è´¥")
                completion(false)
            }
        } catch {
            logger.error("âŒ åˆ›å»ºéŸ³é¢‘æ’­æ”¾å™¨å¤±è´¥: \(error.localizedDescription)")
            completion(false)
        }
    }
    
    /// åœæ­¢éŸ³é¢‘æ’­æ”¾
    func stopAudio() {
        if audioPlayer?.isPlaying == true {
            audioPlayer?.stop()
            
            #if os(iOS)
            do {
                try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
            } catch {
                logger.error("âŒ åœç”¨éŸ³é¢‘ä¼šè¯å¤±è´¥: \(error.localizedDescription)")
            }
            #endif
            
            logger.info("âœ… åœæ­¢éŸ³é¢‘æ’­æ”¾")
        }
    }
    
    // MARK: - ç¼“å­˜ç®¡ç†
    
    /// ç”Ÿæˆç¼“å­˜é”®
    private func generateCacheKey(text: String, voiceType: VoiceType) -> String {
        // ä½¿ç”¨æ–‡æœ¬å’Œè¯­éŸ³ç±»å‹çš„å“ˆå¸Œå€¼ä½œä¸ºç¼“å­˜é”®
        let textHash = text.data(using: .utf8)?.hashValue ?? 0
        let voiceHash = voiceType.rawValue.hashValue
        return "\(abs(textHash))_\(abs(voiceHash))"
    }
    
    /// æ¸…ç†è¿‡æœŸç¼“å­˜
    func cleanExpiredCache() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            
            let fileManager = FileManager.default
            let now = Date()
            
            do {
                // è·å–æ‰€æœ‰ç¼“å­˜æ–‡ä»¶
                let cacheFiles = try fileManager.contentsOfDirectory(at: self.cacheDirectory, includingPropertiesForKeys: [.creationDateKey, .fileSizeKey], options: [])
                
                // è®¡ç®—æ€»ç¼“å­˜å¤§å°
                var totalSize: Int = 0
                var fileInfos: [(url: URL, date: Date, size: Int)] = []
                
                for fileURL in cacheFiles {
                    guard fileURL.pathExtension == "mp3" else { continue }
                    
                    let attributes = try fileURL.resourceValues(forKeys: [.creationDateKey, .fileSizeKey])
                    if let creationDate = attributes.creationDate,
                       let fileSize = attributes.fileSize {
                        totalSize += fileSize
                        fileInfos.append((fileURL, creationDate, fileSize))
                    }
                }
                
                // åˆ é™¤è¿‡æœŸæ–‡ä»¶
                for fileInfo in fileInfos {
                    let age = now.timeIntervalSince(fileInfo.date)
                    if age > self.maxCacheAge {
                        try fileManager.removeItem(at: fileInfo.url)
                        self.logger.info("ğŸ§¹ åˆ é™¤è¿‡æœŸç¼“å­˜æ–‡ä»¶: \(fileInfo.url.lastPathComponent)")
                        totalSize -= fileInfo.size
                    }
                }
                
                // å¦‚æœç¼“å­˜æ€»å¤§å°è¶…è¿‡é™åˆ¶ï¼Œåˆ é™¤æœ€æ—§çš„æ–‡ä»¶
                if totalSize > self.maxCacheSize {
                    // æŒ‰åˆ›å»ºæ—¥æœŸæ’åº
                    let sortedFiles = fileInfos.sorted { $0.date < $1.date }
                    
                    for fileInfo in sortedFiles {
                        if totalSize <= self.maxCacheSize {
                            break
                        }
                        
                        try fileManager.removeItem(at: fileInfo.url)
                        self.logger.info("ğŸ§¹ åˆ é™¤æ—§ç¼“å­˜æ–‡ä»¶ä»¥é‡Šæ”¾ç©ºé—´: \(fileInfo.url.lastPathComponent)")
                        totalSize -= fileInfo.size
                    }
                }
                
                self.logger.info("âœ… ç¼“å­˜æ¸…ç†å®Œæˆï¼Œå½“å‰ç¼“å­˜å¤§å°: \(totalSize / 1024 / 1024)MB")
            } catch {
                self.logger.error("âŒ æ¸…ç†ç¼“å­˜å¤±è´¥: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - è¾…åŠ©æ–¹æ³•
    
    /// æ„å»ºSSML
    private func buildSSML(text: String, voiceName: String) -> String {
        return """
        <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='zh-CN'>
            <voice name='\(voiceName)'>
                <prosody rate='0.9' pitch='0'>
                    \(text)
                </prosody>
            </voice>
        </speak>
        """
    }
    
    // MARK: - AVAudioPlayerDelegate æ–¹æ³•
    
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        logger.info("âœ… éŸ³é¢‘æ’­æ”¾å®Œæˆï¼ŒæˆåŠŸ: \(flag)")
    }
    
    func audioPlayerDecodeErrorDidOccur(_ player: AVAudioPlayer, error: Error?) {
        if let error = error {
            logger.error("âŒ éŸ³é¢‘è§£ç é”™è¯¯: \(error.localizedDescription)")
        }
    }
}

/// è¯­éŸ³åˆæˆä»£ç†
class SpeechSynthesizerDelegate: NSObject, AVSpeechSynthesizerDelegate {
    private let onFinish: () -> Void
    
    init(onFinish: @escaping () -> Void) {
        self.onFinish = onFinish
        super.init()
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        onFinish()
    }
}
#endif 